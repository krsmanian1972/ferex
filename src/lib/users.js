/**
 * id => For Socket . A SRU id, generated by this system.
 * 
 * fuzzyId => For User. A SRU id, generated by external system.
 *  
 */

const OK = 'ok';
const NO = 'no';

// The holder for id and the socket.
const connections = {};

// fuzzyId as Key and its Set of random ids 
const tokens = new Map();



/**
 * There is no guarantee that every socket will have unique ids
 * Hence we tag the sockets with a unique id.
 * 
 * Besides, we need a mechanism to remember the name of the user
 * this fuzzyId belongs for any labeling
 *  
 * @param {*} fuzzyId 
 */
function randomID(fuzzyId,name) {
  const segment = new Date().getTime()
  const uniqueId = Math.random().toString(36).substr(2, 16);

  return fuzzyId + '~' + name+'~'+segment + '~' + uniqueId;
}

/**
 * We create a "secure random id" for the given fuzzyId, because
 * we expect more than one connection for the same fuzzyId during a
 * multi-device setup.
 * 
 * We will then maintain another map to preserve the ids created for
 * such fuzzy ids. - tokens
 * 
 * Every entry of a token is Set for easier removal and uniqueness
 *  
 */
exports.create = async (socket, data) => {
  const fuzzyId = data.fuzzyId;
  const name = data.name;
  const id = randomID(fuzzyId,name);

  if (!tokens.has(fuzzyId)) {
    tokens.set(fuzzyId, new Set());
  }

  tokens.get(fuzzyId).add(id);
  connections[id] = socket;

  return id;
};

/* return ok or no
  The function simply looks for an entry in the tokens map.  
*/
exports.ping = (fuzzyId) => {
  
  if(tokens.has(fuzzyId) && tokens.get(fuzzyId).size > 0) {
    return OK;  
  }

  return NO;
};

// Return the socket associated with the Id
exports.get = (id) => connections[id];


// Delete the socket entry identified by the Id.
// We need to remove the token entry as well.
exports.remove = (id) => {
  if (id) {
    delete connections[id];

    const fuzzyId = id.split("~")[0];
    let ids = tokens.get(fuzzyId);
    if (ids && ids.has(id)) {
      ids.delete(id)
    }

  }
}